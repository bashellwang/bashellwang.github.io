<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bashellwang.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="什么是 JavaScript，它有什么特点？对于客户端原生开发者来说，在学习 JavaScript 过程中，有哪些不得不注意的点？  背景JavaScript 是一种轻量级的脚本语言，同时也是一门动态类型语言。对于 Android 或 iOS 开发者来说，JavaScript 的动态类型特性会让我们在学习过程中遇到各种“坑”，下面将学习过程中需要注意的点罗列出来作为后续备忘使用。(JavaScr">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 中那些不得不注意的点">
<meta property="og:url" content="https://bashellwang.github.io/2022-04-22-JavaScript-%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/index.html">
<meta property="og:site_name" content="bashellwang 的小书屋">
<meta property="og:description" content="什么是 JavaScript，它有什么特点？对于客户端原生开发者来说，在学习 JavaScript 过程中，有哪些不得不注意的点？  背景JavaScript 是一种轻量级的脚本语言，同时也是一门动态类型语言。对于 Android 或 iOS 开发者来说，JavaScript 的动态类型特性会让我们在学习过程中遇到各种“坑”，下面将学习过程中需要注意的点罗列出来作为后续备忘使用。(JavaScr">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-04-22T07:38:35.000Z">
<meta property="article:modified_time" content="2022-04-22T07:47:49.823Z">
<meta property="article:author" content="bashellwang">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bashellwang.github.io/2022-04-22-JavaScript-%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JavaScript 中那些不得不注意的点 | bashellwang 的小书屋</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">bashellwang 的小书屋</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/bashellwang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bashellwang.github.io/2022-04-22-JavaScript-%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="bashellwang">
      <meta itemprop="description" content="路漫漫其修远兮">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bashellwang 的小书屋">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 中那些不得不注意的点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-22 15:38:35 / 修改时间：15:47:49" itemprop="dateCreated datePublished" datetime="2022-04-22T15:38:35+08:00">2022-04-22</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>什么是 JavaScript，它有什么特点？对于客户端原生开发者来说，在学习 JavaScript 过程中，有哪些不得不注意的点？</p>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>JavaScript 是一种轻量级的脚本语言，同时也是一门动态类型语言。对于 Android 或 iOS<br> 开发者来说，JavaScript 的动态类型特性会让我们在学习过程中遇到各种“坑”，下面将学习过程中需要注意的点罗列出来作为后续备忘使用。(JavaScript 基于 ECMAScript 5.1 版本，更多历史背景可参考 <a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/basic/history.html">JavaScript 语言的历史</a>)</p>
<span id="more"></span>
<h4 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h4><h5 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h5><p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</p>
<p>主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
<h5 id="静态语言"><a href="#静态语言" class="headerlink" title="静态语言"></a>静态语言</h5><p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>很多人认为解释型语言都是动态语言，这个观点是错的！Java 是解释型语言但是不是动态语言，Java 不能在运行的时候改变自己结构。反之成立吗？动态语言都是解释型语言。也是错的！Object-C 是编译型语言，但是他是动态语言。得益于特有的 run time 机制（准确说 run time 不是语法特性是运行时环境，这里不展开）OC 代码是可以在运行的时候插入、替换方法的。</p>
<h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><h5 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h5><p>动态类型语言和动态语言是完全不同的两个概念。动态类型语言是指在运行期间才去做数据类型检查的语言，说的是<code>数据类型</code>，动态语言说的是运行是改变结构，说的是<code>代码结构</code>。</p>
<p>动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。</p>
<p>主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。</p>
<h5 id="静态类型语言"><a href="#静态类型语言" class="headerlink" title="静态类型语言"></a>静态类型语言</h5><p>静态语言的数据类型是在编译其间确定的或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型。</p>
<p>主要语言：C、C++、C#、Java、Object-C。</p>
<h4 id="动态类型语言和静态类型语言优缺点"><a href="#动态类型语言和静态类型语言优缺点" class="headerlink" title="动态类型语言和静态类型语言优缺点"></a>动态类型语言和静态类型语言优缺点</h4><table>
<thead>
<tr>
<th>语言</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>静态类型</td>
<td>结构规范，便于调试，方便类型安全</td>
<td>额外编写类型相关代码，代码量增加，注意判断变量类型</td>
</tr>
<tr>
<td>动态类型</td>
<td>提高了编码灵活性，代码量少，方便阅读</td>
<td>不便调试，易发生类型相关错误</td>
</tr>
</tbody></table>
<p>以上我们基本了解了动态语言和静态语言、动态类型语言和静态类型语言以及它们的区别。对于 Java、Object-C 静态类型语言开发者，初学 JavaScript 动态类型语言，可能会有一些点需要特别注意，以下我们将常见易混淆的点进行相关罗列说明。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>数值（number）：整数和小数（比如1和3.14）。</li>
<li>字符串（string）：文本（比如 Hello World ）。</li>
<li>布尔值（boolean）：表示真伪的两个特殊值，即 true（真）和 false（假）。</li>
<li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值。</li>
<li>null：表示空值，即此处的值为空。</li>
<li>对象（object）：各种值组成的集合。</li>
<li>Symbol ：表示独一无二的值，ES6 引入，此文不考虑。</li>
</ul>
<p>通常，数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）；对象是合成类型（complex type）。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升(hoisting)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a = 1;</span><br></pre></td></tr></table></figure>
<p>上面代码首先使用 console.log 方法，在控制台（console）显示变量 a 的值。这时变量 a 还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 1; // undefined</span><br></pre></td></tr></table></figure>

<h4 id="null-和-undefied"><a href="#null-和-undefied" class="headerlink" title="null 和 undefied"></a>null 和 undefied</h4><p><code>undefined</code> 和 <code>null</code> 一般认为是两个特殊值。<code>if</code> 语句中，它们均被认为是 <code>false</code>; 相等运算符 <code>==</code> 两者是相等的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!undefined) &#123;</span><br><span class="line">	console.log(&#x27;undefined is false&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">// undefined is false</span><br><span class="line"></span><br><span class="line">undefined == null // true</span><br><span class="line">undefined === null // false</span><br></pre></td></tr></table></figure>
<p>在转为数值时，<code>null</code> 会转为 0，<code>undefined</code> 会转为 <code>NaN</code>。</p>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 false，其他值都视为 true。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code> 或 <code>&#39;&#39;</code> (空字符串)</li>
</ul>
<p>更多详情可参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/types/null-undefined-boolean.html">null, undefined 和布尔值</a></p>
<h4 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h4><h5 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h5><p>JavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。由于浮点数不是精确值，涉及小数的比较和运算需要特别小心。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 === 1.0 // true</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 // 0.30000000000000004</span><br><span class="line"></span><br><span class="line">0.1 + 0.2 === 0.3 // false</span><br><span class="line"></span><br><span class="line">(0.3 - 0.2) === (0.2 - 0.1) // false</span><br><span class="line"></span><br><span class="line">0.2 + 0.3 === 0.5 // true</span><br><span class="line"></span><br><span class="line">0.2 + 0.2 === 0.4 // true</span><br></pre></td></tr></table></figure>

<h5 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h5><p>JavaScript 内部实际上存在 2 个 0：一个是 +0，一个是 -0，区别就是 64 位浮点数表示法的符号位不同。它们是等价的。</p>
<p>几乎所有场合，正零和负零都会被当作正常的 0。唯一区别的场合，是 <code>+0</code> 或 <code>-0</code> 当作分母，返回值不一样，一个是 <code>+Infinity</code>，另一个是 <code>-Infinity</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0 === +0 // true</span><br><span class="line">0 === +0 // true</span><br><span class="line">0 === -0 // true</span><br><span class="line"></span><br><span class="line">(1 / +0) === (1 / -0) // false</span><br></pre></td></tr></table></figure>

<h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p><code>NaN</code> 是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合，一些数学函数运算结果也会出现 <code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">5 - &#x27;x&#x27; // NaN</span><br><span class="line">Math.acos(2) // NaN</span><br><span class="line">Math.log(-1) // NaN</span><br><span class="line">Math.sqrt(-1) // NaN</span><br><span class="line"></span><br><span class="line">0 / 0 // NaN</span><br><span class="line"></span><br><span class="line">// NaN 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于Number</span><br><span class="line">typeof NaN // &#x27;number&#x27;</span><br><span class="line"></span><br><span class="line">// NaN不等于任何值，包括它本身。</span><br><span class="line">NaN === NaN // false</span><br><span class="line"></span><br><span class="line">// NaN在布尔运算时被当作 false。</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line"></span><br><span class="line">// NaN 与任何数（包括它自己）的运算，得到的都是 NaN。</span><br><span class="line">NaN + 32 // NaN</span><br><span class="line">NaN - 32 // NaN</span><br><span class="line">NaN * 32 // NaN</span><br><span class="line">NaN / 32 // NaN</span><br></pre></td></tr></table></figure>

<h5 id="与数值相关的方法"><a href="#与数值相关的方法" class="headerlink" title="与数值相关的方法"></a>与数值相关的方法</h5><p><code>parseInt</code> 方法用于将字符串转为整数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#x27;123&#x27;) // 123</span><br><span class="line"></span><br><span class="line">// 如果字符串头部有空格，空格会被自动去除。</span><br><span class="line">parseInt(&#x27;   81&#x27;) // 81</span><br><span class="line"></span><br><span class="line">//如果parseInt的参数不是字符串，则会先转为字符串再转换。</span><br><span class="line">parseInt(1.23) // 1</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&#x27;1.23&#x27;) // 1</span><br><span class="line"></span><br><span class="line">// 字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</span><br><span class="line">parseInt(&#x27;8a&#x27;) // 8</span><br><span class="line">parseInt(&#x27;12**&#x27;) // 12</span><br><span class="line">parseInt(&#x27;12.34&#x27;) // 12</span><br><span class="line">parseInt(&#x27;15e2&#x27;) // 15</span><br><span class="line">parseInt(&#x27;15px&#x27;) // 15</span><br><span class="line"></span><br><span class="line">// 如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回 NaN。</span><br><span class="line">parseInt(&#x27;abc&#x27;) // NaN</span><br><span class="line">parseInt(&#x27;.3&#x27;) // NaN</span><br><span class="line">parseInt(&#x27;&#x27;) // NaN</span><br><span class="line">parseInt(&#x27;+&#x27;) // NaN</span><br><span class="line">parseInt(&#x27;+1&#x27;) // 1</span><br><span class="line"></span><br><span class="line">// 如果字符串以 0x 或 0X 开头，parseInt 会将其按照十六进制数解析。</span><br><span class="line">parseInt(&#x27;0x10&#x27;) // 16</span><br><span class="line"></span><br><span class="line">// 如果字符串以 0 开头，将其按照 10 进制解析。</span><br><span class="line">parseInt(&#x27;011&#x27;) // 11</span><br><span class="line"></span><br><span class="line">// 对于那些会自动转为科学计数法的数字，parseInt 会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果</span><br><span class="line">parseInt(1000000000000000000000.5) // 1</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&#x27;1e+21&#x27;) // 1</span><br><span class="line"></span><br><span class="line">parseInt(0.0000008) // 8</span><br><span class="line">// 等同于</span><br><span class="line">parseInt(&#x27;8e-7&#x27;) // 8</span><br></pre></td></tr></table></figure>

<p><code>parseFloat</code> 方法用于将一个字符串转为浮点数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#x27;3.14&#x27;) // 3.14</span><br><span class="line"></span><br><span class="line">// 如果字符串符合科学计数法，则会进行相应的转换。</span><br><span class="line">parseFloat(&#x27;314e-2&#x27;) // 3.14</span><br><span class="line">parseFloat(&#x27;0.0314E+2&#x27;) // 3.14</span><br><span class="line"></span><br><span class="line">// 如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</span><br><span class="line">parseFloat(&#x27;3.14more non-digit characters&#x27;) // 3.14</span><br><span class="line"></span><br><span class="line">// 会自动过滤字符串前导的空格。</span><br><span class="line">parseFloat(&#x27;\t\v\r12.34\n &#x27;) // 12.34</span><br><span class="line"></span><br><span class="line">// 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN。</span><br><span class="line">parseFloat([]) // NaN</span><br><span class="line">parseFloat(&#x27;FF2&#x27;) // NaN</span><br><span class="line">parseFloat(&#x27;&#x27;) // NaN</span><br><span class="line"></span><br><span class="line">// 与 Number 函数的区别</span><br><span class="line">parseFloat(true)  // NaN</span><br><span class="line">Number(true) // 1</span><br><span class="line"></span><br><span class="line">parseFloat(null) // NaN</span><br><span class="line">Number(null) // 0</span><br><span class="line"></span><br><span class="line">parseFloat(&#x27;&#x27;) // NaN</span><br><span class="line">Number(&#x27;&#x27;) // 0</span><br><span class="line"></span><br><span class="line">parseFloat(&#x27;123.45#&#x27;) // 123.45</span><br><span class="line">Number(&#x27;123.45#&#x27;) // NaN</span><br></pre></td></tr></table></figure>

<p><code>isNaN()</code> 方法可以用来判断一个值是否为NaN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN) // true</span><br><span class="line">isNaN(123) // false</span><br><span class="line"></span><br><span class="line">// 但是，isNaN只对数值有效，如果传入其他值，会被先转成数值。也就是说，isNaN 为 true 的值，有可能不是 NaN，而是一个字符串。</span><br><span class="line">isNaN(&#x27;Hello&#x27;) // true</span><br><span class="line">// 相当于</span><br><span class="line">isNaN(Number(&#x27;Hello&#x27;)) // true</span><br><span class="line"></span><br><span class="line">// 出于同样的原因，对于对象和数组，isNaN也返回true。</span><br><span class="line">isNaN(&#123;&#125;) // true</span><br><span class="line">// 等同于</span><br><span class="line">isNaN(Number(&#123;&#125;)) // true</span><br><span class="line"></span><br><span class="line">isNaN([&#x27;xzy&#x27;]) // true</span><br><span class="line">// 等同于</span><br><span class="line">isNaN(Number([&#x27;xzy&#x27;])) // true</span><br><span class="line"></span><br><span class="line">// 但是，对于空数组和只有一个数值成员的数组，isNaN 返回false。</span><br><span class="line">isNaN([]) // false</span><br><span class="line">isNaN([123]) // false</span><br><span class="line">isNaN([&#x27;123&#x27;]) // false</span><br><span class="line"></span><br><span class="line">// 因此，使用isNaN之前，最好判断一下数据类型。</span><br><span class="line">// 判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</span><br><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return value !== value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>isFinite</code> 方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 除了Infinity、-Infinity、NaN 和 undefined 这几个值会返回 false，isFinite 对于其他的数值都会返回 true。</span><br><span class="line">isFinite(Infinity) // false</span><br><span class="line">isFinite(-Infinity) // false</span><br><span class="line">isFinite(NaN) // false</span><br><span class="line">isFinite(undefined) // false</span><br><span class="line">isFinite(null) // true</span><br><span class="line">isFinite(-1) // true</span><br></pre></td></tr></table></figure>
<p>更多详情请参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/types/number.html">数值</a></p>
<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p>
<p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<h5 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h5><p><code>delete</code> 命令用于删除对象的属性，删除成功后返回 <code>true</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">Object.keys(obj) // [&quot;p&quot;]</span><br><span class="line"></span><br><span class="line">delete obj.p // true</span><br><span class="line">obj.p // undefined</span><br><span class="line">Object.keys(obj) // []</span><br><span class="line"></span><br><span class="line">// 注意，删除一个不存在的属性，delete不报错，而且返回true。(此处，上一步已经删除 p 属性，再删除返回 true)</span><br><span class="line">delete obj.p // true</span><br></pre></td></tr></table></figure>

<h5 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h5><p><code>in</code> 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回 true，否则返回 false。</p>
<p><code>in</code> 运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。</p>
<h5 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h5><p><code>for...in</code> 循环用来遍历一个对象的全部属性。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<h5 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h5><p><code>with</code> 语句格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。注意，如果 with 区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 = 4;</span><br><span class="line">  p2 = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 // undefined</span><br><span class="line">p1 // 4</span><br></pre></td></tr></table></figure>
<p>这是因为 with 区块没有改变作用域，它的内部依然是当前作用域。这造成了with语句的一个很大的弊病，就是绑定对象不明确。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。因此，建议不要使用 with 语句，可以考虑用一个临时变量代替 with。</p>
<p>更多详情可参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/types/object.html">对象</a></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>
<p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p>
<h5 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h5><p>JavaScript 引擎将函数名视同变量名，所以采用 function 命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。但是，如果采用赋值语句定义函数，由于“变量提升”，JavaScript 就会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">g();</span><br><span class="line">var g = function ()&#123;&#125;;</span><br><span class="line">// TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>

<p>注意，如果像下面例子那样，采用 function 命令和 var 赋值语句声明同一个函数，由于存在函数提升，最后会采用 var 赋值语句的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(&#x27;1&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(&#x27;2&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() // 1</span><br></pre></td></tr></table></figure>

<h5 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h5><p>函数的 length 属性返回函数预期传入的参数个数，即函数定义之中的参数个数。不管调用时输入了多少个参数，length 属性始终等于定义时参数个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;&#125;</span><br><span class="line">f.length // 2</span><br></pre></td></tr></table></figure>

<h5 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h5><p>根据 JavaScript 的语法，圆括号 () 跟在函数名之后，表示调用该函数。参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/types/function.html#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8Fiife">立即调用的函数表达式</a></p>
<p>更多详情请参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/types/function.html">函数</a></p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从 0 开始），整个数组用方括号表示。本质上，数组属于一种特殊的对象。typeof 运算符会返回数组的类型是 object。</p>
<h5 id="数组-length-属性"><a href="#数组-length-属性" class="headerlink" title="数组 length 属性"></a>数组 length 属性</h5><p>数组的 length 属性，返回数组的成员数量。length 属性的值总是比最大的那个整数键大 1。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ];</span><br><span class="line">arr.length // 3</span><br><span class="line"></span><br><span class="line">// 设置数组 length，可以达到删除效果</span><br><span class="line">arr.length = 2;</span><br><span class="line">arr // [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line"></span><br><span class="line">// 清空数组的一个有效方法，就是将 length 属性设为 0。</span><br><span class="line">arr.length = 0;</span><br><span class="line">arr // []</span><br><span class="line"></span><br><span class="line">// 如果人为设置 length 大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</span><br><span class="line">arr.length = 3;</span><br><span class="line">arr[1] // undefined</span><br><span class="line"></span><br><span class="line">// 由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响 length 属性的值</span><br><span class="line">// 下面代码将数组的键分别设为字符串和小数，结果都不影响 length 属性。因为，length 属性的值就是等于最大的数字键加 1，而这个数组没有整数键，所以 length 属性保持为 0。</span><br><span class="line">var a = [];</span><br><span class="line">a[&#x27;p&#x27;] = &#x27;abc&#x27;;</span><br><span class="line">a.length // 0</span><br><span class="line"></span><br><span class="line">a[2.1] = &#x27;abc&#x27;;</span><br><span class="line">a.length // 0</span><br></pre></td></tr></table></figure>

<h5 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h5><p>检查某个键名是否存在的运算符in，适用于对象，也适用于数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 由于键名都是字符串,数值会转成字符串</span><br><span class="line">var arr = [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];</span><br><span class="line">2 in arr  // true</span><br><span class="line">&#x27;2&#x27; in arr // true</span><br><span class="line">4 in arr // false</span><br><span class="line"></span><br><span class="line">// 如果数组的某个位置是空位，in 运算符返回 false。</span><br><span class="line">var arr = [];</span><br><span class="line">arr[100] = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">100 in arr // true</span><br><span class="line">1 in arr // false</span><br></pre></td></tr></table></figure>
<h5 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h5><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, , 1];</span><br><span class="line">a.length // 3</span><br><span class="line"></span><br><span class="line">// 需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</span><br><span class="line">var a = [1, 2, 3,];</span><br><span class="line"></span><br><span class="line">a.length // 3</span><br><span class="line">a // [1, 2, 3]</span><br><span class="line"></span><br><span class="line">// 数组的空位是可以读取的，返回undefined。</span><br><span class="line">var a = [, , ,];</span><br><span class="line">a[1] // undefined</span><br><span class="line"></span><br><span class="line">// 使用 delete 命令删除一个数组成员，会形成空位，并且不会影响 length 属性。</span><br><span class="line">var a = [1, 2, 3];</span><br><span class="line">delete a[2];</span><br><span class="line"></span><br><span class="line">a[2] // undefined</span><br><span class="line">a.length // 3</span><br></pre></td></tr></table></figure>
<p>数组的某个位置是空位，与某个位置是 undefined，是不一样的。如果是空位，使用数组的 forEach 方法、for…in 结构、以及 Object.keys 方法进行遍历，空位都会被跳过。如果某个位置是 undefined，遍历的时候就不会被跳过。</p>
<h5 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h5><p>如果一个对象的所有键名都是正整数或零，并且有 length 属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象没有数组的 push 方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有 length 属性。只要有 length 属性，就可以认为这个对象类似于数组。但是有一个问题，这种length 属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  0: &#x27;a&#x27;,</span><br><span class="line">  1: &#x27;b&#x27;,</span><br><span class="line">  2: &#x27;c&#x27;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[0] // &#x27;a&#x27;</span><br><span class="line">obj[1] // &#x27;b&#x27;</span><br><span class="line">obj.length // 3</span><br><span class="line">obj.push(&#x27;d&#x27;) // TypeError: obj.push is not a function</span><br></pre></td></tr></table></figure>

<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><h5 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h5><p>加法运算符（<code>+</code>）是最常见的运算符，用来求两个数值的和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1 + 1 // 2</span><br><span class="line"></span><br><span class="line">// 布尔值相加或数值和布尔值相加，布尔值会自动转成数值进行相加</span><br><span class="line">true + true // 2</span><br><span class="line">1 + true // 2</span><br><span class="line"></span><br><span class="line">// 比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</span><br><span class="line">&#x27;a&#x27; + &#x27;bc&#x27; // &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">// 如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</span><br><span class="line">1 + &#x27;a&#x27; // &quot;1a&quot;</span><br><span class="line">false + &#x27;a&#x27; // &quot;falsea&quot;</span><br><span class="line"></span><br><span class="line">// 加法运算符是在运行时决定，到底是执行相加，还是执行连接。也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）</span><br><span class="line">&#x27;3&#x27; + 4 + 5 // &quot;345&quot;</span><br><span class="line">3 + 4 + &#x27;5&#x27; // &quot;75&quot;</span><br><span class="line"></span><br><span class="line">// 除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</span><br><span class="line">1 - &#x27;2&#x27; // -1</span><br><span class="line">1 * &#x27;2&#x27; // 2</span><br><span class="line">1 / &#x27;2&#x27; // 0.5</span><br><span class="line"></span><br><span class="line">// 对象相加：如果运算子是对象，必须先转成原始类型的值，然后再相加。</span><br><span class="line">var obj = &#123; p: 1 &#125;;</span><br><span class="line">obj + 2 // &quot;[object Object]2&quot;</span><br></pre></td></tr></table></figure>

<h5 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h5><p>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12 % 5 // 2</span><br><span class="line"></span><br><span class="line">// 需要注意的是，运算结果的正负号由第一个运算子的正负号决定。</span><br><span class="line">-1 % 2 // -1</span><br><span class="line">1 % -2 // 1</span><br></pre></td></tr></table></figure>

<h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 字符串按照字典顺序进行比较</span><br><span class="line">&#x27;cat&#x27; &gt; &#x27;dog&#x27; // false</span><br><span class="line">&#x27;cat&#x27; &gt; &#x27;catalog&#x27; // false</span><br><span class="line">&#x27;cat&#x27; &gt; &#x27;Cat&#x27; // true</span><br><span class="line"></span><br><span class="line">// 非字符串的比较 -- 如果两个运算子都是原始类型的值，则是先转成数值再比较。</span><br><span class="line">5 &gt; &#x27;4&#x27; // true</span><br><span class="line">true &gt; false // true</span><br><span class="line">2 &gt; true // true</span><br><span class="line"></span><br><span class="line">// 非字符串的比较 -- 如果运算子是对象，会转为原始类型的值，再进行比较。</span><br><span class="line">// 对象转换成原始类型的值，算法是先调用 valueOf 方法；如果返回的还是对象，再接着调用 toString 方法，</span><br><span class="line">var x = [2];</span><br><span class="line">x &gt; &#x27;11&#x27; // true</span><br><span class="line">// 等同于 [2].valueOf().toString() &gt; &#x27;11&#x27;</span><br><span class="line">// 即 &#x27;2&#x27; &gt; &#x27;11&#x27;</span><br><span class="line"></span><br><span class="line">x.valueOf = function () &#123; return &#x27;1&#x27; &#125;;</span><br><span class="line">x &gt; &#x27;11&#x27; // false</span><br><span class="line">// 等同于 [2].valueOf() &gt; &#x27;11&#x27;</span><br><span class="line">// 即 &#x27;1&#x27; &gt; &#x27;11&#x27;</span><br><span class="line"></span><br><span class="line">&#123; x: 2 &#125; &gt;= &#123; x: 1 &#125; // true</span><br><span class="line">// 等同于 &#123; x: 2 &#125;.valueOf().toString() &gt;= &#123; x: 1 &#125;.valueOf().toString()</span><br><span class="line">// 即 &#x27;[object Object]&#x27; &gt;= &#x27;[object Object]&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 这里需要注意与 NaN 的比较。任何值（包括 NaN 本身）与 NaN 使用非相等运算符进行比较，返回的都是 false。</span><br><span class="line">1 &gt; NaN // false</span><br><span class="line">1 &lt;= NaN // false</span><br><span class="line">&#x27;1&#x27; &gt; NaN // false</span><br><span class="line">&#x27;1&#x27; &lt;= NaN // false</span><br><span class="line">NaN &gt; NaN // false</span><br><span class="line">NaN &lt;= NaN // false</span><br></pre></td></tr></table></figure>

<h5 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h5><p>JavaScript 提供两种相等运算符：<code>==</code> 和<code> ===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回 false，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 如果两个值的类型不同，直接返回false。</span><br><span class="line">1 === &quot;1&quot; // false</span><br><span class="line">true === &quot;true&quot; // false</span><br><span class="line"></span><br><span class="line">// 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。</span><br><span class="line">1 === 0x1 // true</span><br><span class="line"></span><br><span class="line">// 需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。</span><br><span class="line">NaN === NaN  // false</span><br><span class="line">+0 === -0 // true</span><br><span class="line"></span><br><span class="line">// 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。</span><br><span class="line">&#123;&#125; === &#123;&#125; // false</span><br><span class="line">[] === [] // false</span><br><span class="line">(function () &#123;&#125; === function () &#123;&#125;) // false</span><br><span class="line"></span><br><span class="line">var v1 = &#123;&#125;;</span><br><span class="line">var v2 = v1;</span><br><span class="line">v1 === v2 // true</span><br><span class="line"></span><br><span class="line">// 注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</span><br><span class="line">var obj1 = &#123;&#125;;</span><br><span class="line">var obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1 &gt; obj2 // false</span><br><span class="line">obj1 &lt; obj2 // false</span><br><span class="line">obj1 === obj2 // false</span><br><span class="line"></span><br><span class="line">// undefined和null与自身严格相等。</span><br><span class="line">undefined === undefined // true</span><br><span class="line">null === null // true</span><br></pre></td></tr></table></figure>

<h5 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h5><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。</p>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。详情可参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/operators/comparison.html#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6">相等运算符</a></p>
<h5 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h5><p>且运算符(<code>&amp;&amp;</code>) 往往用于多个表达式的求值。</p>
<p>它的运算规则是：如果第一个运算子的布尔值为 true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为 false，则直接返回第一个运算子的值，且不再对第二个运算子求值。这种跳过第二个运算子的机制，被称为<code>短路</code>。</p>
<p>且运算符可以多个连用，这时返回第一个布尔值为 false 的表达式的值。如果所有表达式的布尔值都为 true，则返回最后一个表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x27;t&#x27; &amp;&amp; &#x27;&#x27; // &quot;&quot;</span><br><span class="line">&#x27;t&#x27; &amp;&amp; &#x27;f&#x27; // &quot;f&quot;</span><br><span class="line">&#x27;t&#x27; &amp;&amp; (1 + 2) // 3</span><br><span class="line">&#x27;&#x27; &amp;&amp; &#x27;f&#x27; // &quot;&quot;</span><br><span class="line">&#x27;&#x27; &amp;&amp; &#x27;&#x27; // &quot;&quot;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">(1 - 1) &amp;&amp; ( x += 1) // 0</span><br><span class="line">x // 1</span><br><span class="line"></span><br><span class="line">true &amp;&amp; &#x27;foo&#x27; &amp;&amp; &#x27;&#x27; &amp;&amp; 4 &amp;&amp; &#x27;foo&#x27; &amp;&amp; true</span><br><span class="line">// &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">1 &amp;&amp; 2 &amp;&amp; 3</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>

<p>或运算符（<code>||</code>）也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为 true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为 false，则返回第二个运算子的值。</p>
<p>或运算符可以多个连用，这时返回第一个布尔值为 true 的表达式的值。如果所有表达式都为 false，则返回最后一个表达式的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x27;t&#x27; || &#x27;&#x27; // &quot;t&quot;</span><br><span class="line">&#x27;t&#x27; || &#x27;f&#x27; // &quot;t&quot;</span><br><span class="line">&#x27;&#x27; || &#x27;f&#x27; // &quot;f&quot;</span><br><span class="line">&#x27;&#x27; || &#x27;&#x27; // &quot;&quot;</span><br><span class="line"></span><br><span class="line">false || 0 || &#x27;&#x27; || 4 || &#x27;foo&#x27; || true</span><br><span class="line">// 4</span><br><span class="line"></span><br><span class="line">false || 0 || &#x27;&#x27;</span><br><span class="line">// &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>更多运算符详情请参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/operators/index.html">运算符</a></p>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>强制转换主要指使用 Number()、String() 和 Boolean() 三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number ()"></a>Number ()</h5><p>Number 函数将字符串转为数值，要比 parseInt 函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为 NaN。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 数值：转换后还是原来的值</span><br><span class="line">Number(324) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="line">Number(&#x27;324&#x27;) // 324</span><br><span class="line"></span><br><span class="line">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="line">Number(&#x27;324abc&#x27;) // NaN</span><br><span class="line"></span><br><span class="line">// 空字符串转为0</span><br><span class="line">Number(&#x27;&#x27;) // 0</span><br><span class="line"></span><br><span class="line">// 布尔值：true 转成 1，false 转成 0</span><br><span class="line">Number(true) // 1</span><br><span class="line">Number(false) // 0</span><br><span class="line"></span><br><span class="line">// undefined：转成 NaN</span><br><span class="line">Number(undefined) // NaN</span><br><span class="line"></span><br><span class="line">// null：转成0</span><br><span class="line">Number(null) // 0</span><br><span class="line"></span><br><span class="line">// 另外，parseInt 和 Number 函数都会自动过滤一个字符串前导和后缀的空格。</span><br><span class="line">parseInt(&#x27;\t\v\r12.34\n&#x27;) // 12</span><br><span class="line">Number(&#x27;\t\v\r12.34\n&#x27;) // 12.34</span><br><span class="line"></span><br><span class="line">Number(&#123;a: 1&#125;) // NaN</span><br><span class="line">Number([1, 2, 3]) // NaN</span><br><span class="line">Number([5]) // 5</span><br></pre></td></tr></table></figure>
<p>Number 背后的转换规则比较复杂。</p>
<p>第一步，调用对象自身的 valueOf 方法。如果返回原始类型的值，则直接对该值使用 Number 函数，不再进行后续步骤。</p>
<p>第二步，如果 valueOf 方法返回的还是对象，则改为调用对象自身的 toString 方法。如果 toString 方法返回原始类型的值，则对该值使用 Number 函数，不再进行后续步骤。</p>
<p>第三步，如果 toString 方法返回的是对象，就报错。</p>
<h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h5><p>Boolean() 函数可以将任意类型的值转为布尔值。除了以下五个值的转换结果为 false，其他的值全部为 true。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line">Boolean(&#x27;&#x27;) // false</span><br><span class="line"></span><br><span class="line">Boolean(true) // true</span><br><span class="line">Boolean(false) // false</span><br><span class="line"></span><br><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(new Boolean(false)) // true</span><br></pre></td></tr></table></figure>
<p>更多详情请参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/features/conversion.html">数据类型转换</a></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>分号表示一条语句的结束。JavaScript 允许省略行尾的分号。以下三种情况，语法规定不需要在结尾添加分号，如果添加也不会出错，因为解释引擎会把这个分号解释为空语句。</p>
<ul>
<li>for 和 while 循环</li>
<li>分支语句：if，switch，try</li>
<li>函数声明语句</li>
</ul>
<p>除了上面三种情况，所有语句都应该使用分号。同时，对于大多数情况，JavaScrip 会自动添加分号。这种语法特性被称为 “分号的自动添加”(<code>Automatic Semicolon Insertion，简称 ASI</code>)。由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</p>
<p>详情参考：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/features/style.html#%E8%A1%8C%E5%B0%BE%E7%9A%84%E5%88%86%E5%8F%B7">行尾的分号</a></p>
<h4 id="标准库对象及方法"><a href="#标准库对象及方法" class="headerlink" title="标准库对象及方法"></a>标准库对象及方法</h4><h5 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h5><p>数组构造函数的行为不统一：<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/array.html#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">Array 构造函数</a></p>
<p>Array 的一些操作符，哪些改变原数组，哪些不改变原数组 <a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/array.html">array</a></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>是否改变原数组</th>
</tr>
</thead>
<tbody><tr>
<td>valueOf()</td>
<td>对该对象求值，不同对象的实现不一致，数组的valueOf方法返回数组本身</td>
<td>否</td>
</tr>
<tr>
<td>toString()</td>
<td>是对象的通用方法，数组的toString方法返回数组的字符串形式</td>
<td>否</td>
</tr>
<tr>
<td>push()</td>
<td>用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度</td>
<td>是</td>
</tr>
<tr>
<td>pop()</td>
<td>用于删除数组的最后一个元素，并返回该元素</td>
<td>是</td>
</tr>
<tr>
<td>shift()</td>
<td>用于删除数组的第一个元素，并返回该元素</td>
<td>是</td>
</tr>
<tr>
<td>unshift()</td>
<td>用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度</td>
<td>是</td>
</tr>
<tr>
<td>join()</td>
<td>以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔</td>
<td>否</td>
</tr>
<tr>
<td>concat()</td>
<td>用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组</td>
<td>否</td>
</tr>
<tr>
<td>reverse()</td>
<td>用于颠倒排列数组元素，返回改变后的数组</td>
<td>是</td>
</tr>
<tr>
<td>slice()</td>
<td>用于提取目标数组的一部分，返回一个新数组</td>
<td>否</td>
</tr>
<tr>
<td>splice()</td>
<td>用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素</td>
<td>是</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组成员进行排序，默认是按照字典顺序排序</td>
<td>是</td>
</tr>
<tr>
<td>map()</td>
<td>将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回</td>
<td>否</td>
</tr>
<tr>
<td>forEach()</td>
<td>对数组的所有成员依次执行参数函数，但是不返回值，只用来操作数据</td>
<td>否</td>
</tr>
<tr>
<td>filter()</td>
<td>用于过滤数组成员，满足条件的成员组成一个新数组返回</td>
<td>否</td>
</tr>
<tr>
<td>some()</td>
<td>类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false</td>
<td>否</td>
</tr>
<tr>
<td>every()</td>
<td>类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件; 所有成员的返回值都是true，整个every方法才返回true，否则返回false</td>
<td>否</td>
</tr>
<tr>
<td>reduce()</td>
<td>依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）</td>
<td>否</td>
</tr>
<tr>
<td>reduceRight()</td>
<td>依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）</td>
<td>否</td>
</tr>
<tr>
<td>indexOf()</td>
<td>返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</td>
<td>否</td>
</tr>
<tr>
<td>lastIndexOf()</td>
<td>返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1</td>
<td>否</td>
</tr>
</tbody></table>
<h5 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h5><p>Number 对象的实例方法，数值需要放在括号里，不然会被 JavaScript 引擎解释成小数点，从而报错。<br>只要能够让 JavaScript 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为数值加上括号，还可以在数值后面加两个点，JavaScript 会把第一个点理解成小数点，把第二个点理解成调用对象属性，从而得到正确结果</p>
<p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/number.html#numberprototypetofixed">toFixed()</a><br>toFixed() 方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。由于浮点数的原因，小数 5 的四舍五入是不确定的，使用的时候必须小心。</p>
<h5 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h5><p>String 实例方法，substring 违反直觉，建议使用 slice 方法。<a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/stdlib/string.html#stringprototypesubstring">substring</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文简单说明了动态类型语言、静态类型语言的区别，归纳总结了 JavaScript 学习过程中容易混淆以及出错的点，尤其是数据类型和运算符这块。对于初学 JavaScript 语言者，希望可以起到一定的帮助。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zy1987/p/3784753.html?utm_source=tuicool&utm_medium=referral">编译型语言、解释型语言、静态类型语言、动态类型语言概念与区别 </a></li>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/index.html">JavaScript 教程</a></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>bashellwang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://bashellwang.github.io/2022-04-22-JavaScript-%E4%B8%AD%E9%82%A3%E4%BA%9B%E4%B8%8D%E5%BE%97%E4%B8%8D%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9/" title="JavaScript 中那些不得不注意的点">https://bashellwang.github.io/2022-04-22-JavaScript-中那些不得不注意的点/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021-12-11-gradle-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" rel="prev" title="Gradle 依赖管理的几种方式">
      <i class="fa fa-chevron-left"></i> Gradle 依赖管理的几种方式
    </a></div>
      <div class="post-nav-item">
    <a href="/2022-06-10-Nginx-%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/" rel="next" title="Nginx 配置入门">
      Nginx 配置入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">动态语言和静态语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.1.</span> <span class="nav-text">动态语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-number">1.1.2.</span> <span class="nav-text">静态语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">1.1.3.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">1.2.</span> <span class="nav-text">动态类型语言和静态类型语言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">1.2.1.</span> <span class="nav-text">动态类型语言</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80"><span class="nav-number">1.2.2.</span> <span class="nav-text">静态类型语言</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.3.</span> <span class="nav-text">动态类型语言和静态类型语言优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-number">2.1.1.</span> <span class="nav-text">变量提升</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#null-%E5%92%8C-undefied"><span class="nav-number">2.2.</span> <span class="nav-text">null 和 undefied</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC"><span class="nav-number">2.3.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E5%80%BC"><span class="nav-number">2.4.</span> <span class="nav-text">数值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">2.4.1.</span> <span class="nav-text">整数和浮点数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%A3%E9%9B%B6%E5%92%8C%E8%B4%9F%E9%9B%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">正零和负零</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NaN"><span class="nav-number">2.4.3.</span> <span class="nav-text">NaN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.4.4.</span> <span class="nav-text">与数值相关的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.5.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">2.5.1.</span> <span class="nav-text">属性的删除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%EF%BC%9Ain-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.5.2.</span> <span class="nav-text">属性是否存在：in 运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">2.5.3.</span> <span class="nav-text">属性的遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#with-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.5.4.</span> <span class="nav-text">with 语句</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D%E7%9A%84%E6%8F%90%E5%8D%87"><span class="nav-number">2.6.1.</span> <span class="nav-text">函数名的提升</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#length-%E5%B1%9E%E6%80%A7"><span class="nav-number">2.6.2.</span> <span class="nav-text">length 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89"><span class="nav-number">2.6.3.</span> <span class="nav-text">立即调用的函数表达式（IIFE）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.7.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-length-%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.1.</span> <span class="nav-text">数组 length 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#in-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.7.2.</span> <span class="nav-text">in 运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E7%A9%BA%E4%BD%8D"><span class="nav-number">2.7.3.</span> <span class="nav-text">数组的空位</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E4%BC%BC%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.7.4.</span> <span class="nav-text">类似数组的对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.</span> <span class="nav-text">算术运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.1.</span> <span class="nav-text">加法运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%99%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.2.</span> <span class="nav-text">余数运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.3.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.4.</span> <span class="nav-text">严格相等运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.5.</span> <span class="nav-text">相等运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">2.8.6.</span> <span class="nav-text">布尔运算符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.9.</span> <span class="nav-text">数据类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Number"><span class="nav-number">2.9.1.</span> <span class="nav-text">Number ()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Boolean"><span class="nav-number">2.9.2.</span> <span class="nav-text">Boolean()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">2.10.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AF%B9%E8%B1%A1%E5%8F%8A%E6%96%B9%E6%B3%95"><span class="nav-number">2.11.</span> <span class="nav-text">标准库对象及方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Array-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.1.</span> <span class="nav-text">Array 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Number-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.2.</span> <span class="nav-text">Number 对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.11.3.</span> <span class="nav-text">String 对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">4.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="bashellwang"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">bashellwang</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/bashellwang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;bashellwang" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://theme-next.iissnan.com/theme-settings.html" title="http:&#x2F;&#x2F;theme-next.iissnan.com&#x2F;theme-settings.html" rel="noopener" target="_blank">Next</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;0014316089557264a6b348958f449949df42a6d3a2e542c000" rel="noopener" target="_blank">Python</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bashellwang</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
