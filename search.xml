<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3 入门之函数基础]]></title>
    <url>%2F2017%2F08%2F22%2F2017-08-22%20Python3%20%E5%85%A5%E9%97%A8%E4%B9%8B%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[函数基础函数是最基本的一种代码抽象方式 条件判断根据 Python 的缩进规则，如果 if 语句判断为 True ，就把接下来缩进的语句执行，否则执行 else 的内容 1234567&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age&gt;= 18:... print(&quot;your age is&quot;,age)... else:... print(&quot;haha child&quot;)...your age is 20 注意不要漏了 : ，也可以使用 elif 来表示 else if 。 12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; if 语句是从上向下判断的，如果在某个判断上为 True,则把对应语句执行后就忽略掉剩下的语句。 if 语句可以简写如下： 12if x: print(&apos;True&apos;) 只要 x 是非零数值、非空字符串、非空list等，就判断为 True，否则为 False。 再看 input我们使用 input() 来获取用户的输入，比如以下程序段：12345birth = input(&apos;birth: &apos;)if birth &lt; 2000: print(&apos;00前&apos;)else: print(&apos;00后&apos;) 输入 1982 或 abc 均会报错，这是为什么呢？ 原来 input() 返回的数据类型是 str ,它是不能直接和整数相比较的，我们必须把它进行转换。 使用 int() 可以转换 1982 为整数；而 abc 则需要进行数据类型的合法检查，它是不能转换成整数的。 循环Python 的循环有两种，一种是 for ... in 循环，一种是 while 循环 for 循环for 循环依次把 list 或 tuple 中的每个元素迭代出来 1234567&gt;&gt;&gt; names = [&apos;jack&apos;,&apos;tom&apos;,&apos;rose&apos;]&gt;&gt;&gt; for name in names:... print(name)...jacktomrose Python 提供了一个 range() 函数，再通过 list() 函数可以将其转换为 list。比如 range(101) 就是生存从 0 开始小于 101 的整数序列。 123456&gt;&gt;&gt; sum = 0&gt;&gt;&gt; for x in range(101):... sum = sum + x...&gt;&gt;&gt; print(sum)5050 while 循环while 循环是只要条件满足，就不断循环；条件不满足时，退出循环 12345678&gt;&gt;&gt; sum = 0&gt;&gt;&gt; n = 100&gt;&gt;&gt; while n &gt; 0:... sum = sum + n... n = n - 1...&gt;&gt;&gt; print(sum)5050 break在循环中，break 语句可以提前退出循环 continue 语句可以跳过这次循环，直接开始下一次循环 函数调用Python 内置了很多函数，可以直接调用。调用函数需要知道函数名及函数参数，可参考 官方文档 当调用函数出错时，系统会给出相应的错误信息，查看信息即可知道原因并进行修改 max 函数max() 函数可以接收多个参数，并输出其中最大的那个 12&gt;&gt;&gt; max(2,0,-5,8)8 数据类型转换函数123456789101112&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float(&apos;12.34&apos;)12.34&gt;&gt;&gt; str(1.23)&apos;1.23&apos;&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool(&apos;&apos;)False 函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个「别名」： 123&gt;&gt;&gt; a = int&gt;&gt;&gt; a(&apos;123&apos;)123 函数定义在 Python 中定义一个函数需要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号，在缩进块中编写函数体，函数的返回值使用 return 返回。 1234567def isGood(x): if x&gt;=60: return True else : return Falseprint(isGood(89)) 函数体内部一旦执行到 return 时，函数就执行完毕，并将结果返回。如果没有 return 语句，函数执行完毕后也会返回结果，只不过结果是 None 。return None 可以简写为 return 。 空函数如果想定义一个空函数，什么也不干，那么可以使用 pass 语句；实际上 pass 语句可以用来做占位符，比如现在没有想好该怎么做，就可以先使用 pass 语句让代码跑起来。 12def nop(): pass pass 语句还可以放在其它语句里，比如： 12if age &gt;= 18: pass 如果缺少 pass，则程序会报错 参数检查调用参数时，如果参数个数不对，Python 解释器会自动检查出来并抛出错误 TypeError 我们可以给自己的函数加上参数类型检测，使用 isinstance() 内置函数方法。如下是只允许整数和浮点数类型的参数：123456789def isGood(x): if not isinstance(x,(int,float)): raise TypeError(&apos;bad operation type&apos;) if x&gt;=60 : return True else : return Falseprint(isGood(89)) 返回多个值函数是可以返回多个值的。比如游戏中从其中一个点移动到另一个点，给出坐标、位移、角度，可以计算出新的坐标：123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 我们可以同时获得返回值 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0 但是这只是一个假象，Python 函数返回的仍是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0) 原来返回的是一个 tuple ！在语法上，返回一个 tuple 可以省略括号，而多个变量可以同时接收一个 tuple，按位置给对应的值。所以，Python 的函数返回多个值其实就是返回一个 tuple。 函数的参数Python 的函数定义非常简单，灵活度很大，除了必须的参数外，还有默认参数、可变参数和关键字参数。 位置参数12def power(x): return x * x 对于该函数来说，x 就是一个位置参数；当我们对函数进行改造以便生成 x 的 n 次方：123456def power(x,n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 修改后的函数有两个参数，两个都是位置参数，调用函数时，传入的值按照位置顺序依次赋给参数。 默认参数新建的函数 power(x,n) 调用没有问题，但是原有的一个参数的函数调用出问题了，系统告诉我们是因为缺少一个位置参数。因此，我们可以将第二个参数的默认值设置为 n = 2 :123456def power(x,n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样，当我们调用 power(5) 时，实际就是调用 power(5,2)。而对于其它 n&gt;2 的情况下，则必须明确的传入参数值。 注意： 必选参数在前，默认参数在后 变化大的参数放在前面，变化小的参数放在后面；变化小的参数可以作为默认参数 默认参数降低了函数调用的难度 当有多个默认参数时，既可以按顺序提供默认参数，也可以不按顺序提供默认参数 当不按顺序提供默认参数时，必须要把参数名写上 默认参数必须指向不变对象 可变参数Python 中，可以定义可变参数。可变参数就是参数的个数是可变的，可以是 1 个，2 个到任意个，也可以是 0 个。 12345def calc(*numbers) sum = 0 for n in numbers: sum = sum + n * n return sum 定义一个可变参数和定义一个 list 或 tuple 相比，仅仅在参数前多了一个 号。` numbers` 表示把 numbers 这个 list 的所有元素作为可变参数传进去。 关键字参数可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装成一个 tuple。而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。12def person(name,age,**kw) print(&apos;name&apos;,name,&apos;age&apos;,age,&apos;other&apos;,kw) 可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person(&apos;Bob&apos;, 35, city=&apos;Beijing&apos;)name: Bob age: 35 other: &#123;&apos;city&apos;: &apos;Beijing&apos;&#125;&gt;&gt;&gt; person(&apos;Adam&apos;, 45, gender=&apos;M&apos;, job=&apos;Engineer&apos;)name: Adam age: 45 other: &#123;&apos;gender&apos;: &apos;M&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 这种函数可以扩展函数功能，除了保证能接收到必要参数，对于调用者额外提供的参数也能获取到。 和可变参数一样，我们也可以先组装出一个 dict，然后把该 dict 转换为关键字参数传进去。 123&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;&gt;&gt;&gt; person(&apos;Jack&apos;, 24, city=extra[&apos;city&apos;], job=extra[&apos;job&apos;])name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; 上面可以简化为如下写法： 123&gt;&gt;&gt; extra = &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125;&gt;&gt;&gt; person(&apos;Jack&apos;, 24, **extra)name: Jack age: 24 other: &#123;&apos;city&apos;: &apos;Beijing&apos;, &apos;job&apos;: &apos;Engineer&apos;&#125; **extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 **kw 参数，kw 将获得一个 dict，注意 kw 获得的dict 是 extra 的一份拷贝，对 kw 的改动不会影响到函数外的 extra。 命名关键字参数对于关键字参数，函数调用者可以传入任意不受限制的关键字参数。对于传入参数的判断，只能在 kw 内部进行检查。以上面的 person() 函数为例，当我们只想调用者传入 city 和 job 做为关键字参数时，我们就可以使用「命名关键字参数」。这种函数的定义如下：12def person(name,age,*,city,job) print(name,age,city,job) 和关键字参数不一样的地方就是命名关键字参数需要使用分隔符 * ，* 后面的参数被视为命名关键字参数。 如果函数定义中已经有了一个可变参数，那么后面跟着的命名关键字参数就不再需要 * 分隔符了。 12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数和位置参数不同，它必须要传入参数名，否则将报错。命名关键字参数可以有缺省值，类似默认参数。12def person(name, age, *, city=&apos;Beijing&apos;, job): print(name, age, city, job) 使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个 * 作为特殊分隔符。如果缺少 * ，Python 解释器将无法识别位置参数和命名关键字参数：123def person(name, age, city, job): # 缺少 *，city和job被视为位置参数 pass 参数组合在 Python 中定义函数，可以使用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这五种参数都可以组合使用。但是，参数的定义顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数12345def f1(a, b, c=0, *args, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;args =&apos;, args, &apos;kw =&apos;, kw)def f2(a, b, c=0, *, d, **kw): print(&apos;a =&apos;, a, &apos;b =&apos;, b, &apos;c =&apos;, c, &apos;d =&apos;, d, &apos;kw =&apos;, kw) 调用结果如下： 12345678910&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, &apos;a&apos;, &apos;b&apos;, x=99)a = 1 b = 2 c = 3 args = (&apos;a&apos;, &apos;b&apos;) kw = &#123;&apos;x&apos;: 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;&apos;ext&apos;: None&#125; 通过一个 tuple 和 dict ，也可以调用上述函数： 12345678&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;&apos;d&apos;: 99, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;&apos;d&apos;: 88, &apos;x&apos;: &apos;#&apos;&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;&apos;x&apos;: &apos;#&apos;&#125; 因此，对于任意函数，均可以使用类似 func(*args,**kw) 的形式进行调用，而不管它的参数是如何定义的。 小结Python 的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ 要注意定义可变参数和关键字参数的语法： *args 是可变参数，args 接收的是一个 tuple； **kw 是关键字参数，kw 接收的是一个 dict。 以及调用函数时如何传入可变参数和关键字参数的语法： 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装 list 或 tuple，再通过 *args 传入：func(*(1, 2, 3))； 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过 **kw 传入：func(**{‘a’: 1, ‘b’: 2})。 使用 *args 和 **kw 是 Python 的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。 命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python3 入门之基础语法]]></title>
    <url>%2F2017%2F08%2F09%2F2017-08-09%20Python3%20%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[输入和输出计算机程序都是需要进行输入，并将计算结果反馈输出。输入是 Input，输出是 Output，统称 Input/Output，简称 I/O。 输出使用 print() 方法可以输出指定字符串到屏幕上 括号中填入要输出的字符串即可 该函数可以接受多个字符串，使用逗号 , 隔开，即可将字符串拼接成一串输出 在拼接字符串的时候，使用空格替换 , 可以打印整数，进行数学计算 例子如下所示： 12&gt;&gt;&gt; print(&apos;This is&apos;,&apos;a example&apos;,&apos;for output method:&apos;,&apos;5+6 =&apos;,5+6)This is a example for output method: 5+6 = 11 输入使用 input() 可以让用户输入字符串，并存放到一个变量中 1234&gt;&gt;&gt; name = input(&apos;please input your name: &apos;)please input your name: bashellwang&gt;&gt;&gt; print(name)bashellwang Python 基础 Python 使用缩进来组织代码块，每一行都是一个语句 当语句以 : 结尾时，缩进的语句视为代码块 一般使用 4 个空格的锁进，文本编辑器中需要设置把 Tab 自动转换为 4 个空格，确保不混用 Tab 和空格 Python 程序是大小写敏感的 数据类型和变量整数Python 可以处理任意大小的整数，包括负整数，没有大小限制 浮点数浮点数没有大小写限制，但是超过一定范围就直接表示为 inf（无限大）。 字符串以单引号 &#39; 或 &quot; 括起来的文本。&#39; 和 &quot; 本身是一种表示方式，如果想要显示它们，需要使用转义字符 \ 来标识。 转义字符可以转义很多字符，比如 \n 表示换行，\t 表示制表符，\\ 表示转义字符本身 123&gt;&gt;&gt; print(&apos;this is a \\n string ,\nthe result is string&apos;)this is a \n string ,the result is string 如果有很多转义字符，就需要增加很多 \ 为了简化，Python 可以使用 r&#39;&#39; 表示 &#39;&#39; 内部的字符串默认不转义 Python 可以使用 &#39;&#39;&#39;...&#39;&#39;&#39; 格式来表示多行内容（命令行里显示为 ...，文本编辑器里则没有 ... ） 多行字符串 &#39;&#39;&#39;...&#39;&#39;&#39; 还可以在前面加上 r 使用 1234567891011121314&gt;&gt;&gt; print(&apos;\\\t\\&apos;)\ \&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)\\\t\\&gt;&gt;&gt; print(&apos;&apos;&apos;line1... line2... line3&apos;&apos;&apos;)line1line2line3&gt;&gt;&gt; print(r&apos;&apos;&apos;\\hello... wold \\n&apos;&apos;&apos;)\\hellowold \\n 布尔值 布尔值与布尔代数的运算完全一样，布尔值只有 True 和 False 两种（注意大小写） 布尔值可以进行与、或、非等运算： and or not 空值空值是 Python 中的一个特殊值，使用 None 表示，它不能理解为 0，因为 0 表示为整数。 变量 变量和我们代数中理解的方程变量是一样的，在程序里变量可以是任意数据类型。 变量使用变量名来表示，变量名必须是大小写英文、数字和下划线的组合，且不能以数字开头 = 是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量 这种变量本身类型不固定的语言称之为动态语言，与之对应的则是静态语言。静态语言在定义时必须指定变量类型，如果赋值时类型不匹配，则会报错。 可以把一个变量 a 赋值给另一个变量 b，这个操作实质上是把变量 b 指向变量 a 所指向的数据 12345&gt;&gt;&gt; a=&apos;ABC&apos;&gt;&gt;&gt; b=a&gt;&gt;&gt; a=&apos;xyz&apos;&gt;&gt;&gt; print(b)ABC 常量所谓常量就是不能变的变量，在 Python 中，通常用全部大写的变量名表示常量。不过全部大写只是一种习惯写法，本质上它还是一个变量，如果你非要改变它的值，也是可以的。 / 除法计算，结果是浮点数，即使是两个整数整除 // 地板除，两个整数的除法为整数，就是结果取整 % 求余计算，结果为整数 listlist 是一种有序的集合，叫「列表」，它可以随时添加和删除其中的元素。 使用中括号 [] 来表示，如：list = [&#39;Zhangsan&#39;,&#39;Lisi&#39;,&#39;Wangwu&#39;] 用索引来访问，从 0 开始，list[0] 索引越界时会报错 IndexError list[-1] 可以直接获取最后一个元素，以此类推倒数第二个，第三个元素 列表可以追加元素到末尾，list.append(&#39;abc&#39;) 列表可以把元素插入到指定位置，list.insert(1,&#39;abc&#39;) 删除 list 末尾的元素，使用 pop() 方法 删除指定位置元素，使用 pop(i) 方法 替换某个元素，可以直接给它赋值对应的值 list 里面的元素的数据类型可以不一样，L = [&#39;Apple&#39;,12,[&#39;apple&#39;,True]] tupletuple 是另一种有序列表，叫「元组」，但是 tuple 一旦初始化，就不能修改。 使用小括号 () 来表示，在定义时，tuple 的元素必须被确定下来,如：tuple = (&#39;Zhangsan&#39;,&#39;Lisi&#39;,&#39;Wangwu&#39;) 定义一个空的 tuple，可以写成 t = () 定义一个只有一个元素的 tuple，必须是 t = (1,) ，元素后添加一个逗号表示 获取元素与列表一样，tuple[0], tuple[-1] 等方式 定义一个「可变」的 tuple 12345&gt;&gt;&gt; t = (&apos;a&apos;,&apos;b&apos;,[&apos;A&apos;,&apos;B&apos;])&gt;&gt;&gt; t[2][0]=&apos;X&apos;&gt;&gt;&gt; t[2][1]=&apos;Y&apos;&gt;&gt;&gt; t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 表面上看，tuple 的元素确实变了，但其实变的不是 tuple 的元素，而是 list 的元素。tuple 一开始指向的 list 并没有改成别的 list，所以，tuple 所谓的「不变」是说，tuple 的每个元素，指向永远不变。即指向 a，就不能改成指向 b，指向一个 list，就不能改成指向其他对象，但指向的这个 list 本身是可变的！ 理解了「指向不变」后，要创建一个内容也不变的 tuple 怎么做？那就必须保证 tuple 的每一个元素本身也不能变。 dict dict 全称 dictionary，名为字典，在其它语言中称为「map」，使用「键-值 (key-value)」形式存储 使用大括号 {} 表示，如：dict = {&#39;Zhangsan&#39;:18,&#39;Lisi&#39;:20,&#39;Wangwu&#39;:18} 数据除了初始化时设置外，还可以通过 key 设置值 dict 的 key 必须是不可变对象 获取值使用 dict[key] 方式 多次设置值时，后面的赋值会将前面的覆盖掉 key 不存在时会报错，在获取值时可以先使用 in 来判断 key 是否存在 通过 get 方法，如果 key 不存在，则返回 None 或指定值 删除一个 key，使用 pop(key) 方法，对应 value 也会被删除 dict 内部存放顺序与 key 放入顺序无关，是无序的 查找速度极快，占用内存空间高，即空间换时间 set 和 dict 类似，也是一组 key 的集合，但不存储 value；无序，无重复 key 创建一个 set，需要提供一个 list 作为输入集合，如：set = ([1,2,3])，表示 set 内部有三个元素 重复元素在 set 中自动被过滤 通过 add(key) 方法可以添加元素到 set 中，可重复添加，但是无效果 通过 remove(key) 方法可以删除元素 set 可以看作数学意义上的无序和无重复元素集合，因此两个 set 可以做数学意义上的交集、并集等运算 不可以放入可变对象 set 和 dict 唯一区别就是没有存储对应的 value 字符串和编码字符编码可以看看这篇文章 字符编码 在最新的 Python 3 版本中，字符串是以 Unicode 编码的。如果要在网络上传输或者保存到磁盘上，需要把 str 变为以字节为单位的 bytes。Python 中对 bytes 类型的数据用带 b 前缀的单引号或双引号表示，每个 bytes 占用一个字节。 以 Unicode 表示的 str 通过 encode() 方法可以编码为指定的 bytes。纯英文的 str 可以用 ASCII 编码为 bytes，内容是一样的，含有中文的 str 可以用 UTF-8 编码为 bytes。含有中文的 str 无法用 ASCII 编码，因为中文编码的范围超过了 ASCII 编码的范围，Python 会报错。在 bytes 中，无法显示为 ASCII 字符的字节，用 \x## 表示。 反过来，从网络或磁盘上获取的字节流，读取的数据为 bytes，需要使用 decode() 方法转换为 str。 len() 函数计算的是字符串 str 的字符数或者 bytes 的字节数。 由于 Python 源代码是一个文本文件，当源码中包含中文时，务必要指定保存为 UTF-8 编码。通常我们在文件开头写上这两行： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉 Linux/OS X 系统，这是一个 Python 可执行程序，Windows 系统会忽略这个注释； 第二行注释是为了告诉 Python 解释器，按照 UTF-8 编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 申明了 UTF-8 编码并不意味着你的 .py 文件就是 UTF-8 编码的，必须并且要确保文本编辑器正在使用 UTF-8 without BOM 编码 字符串的格式化Python 中，采用与 C 语言一致的格式化方法，使用 % 实现 %s 字符串替换 %d 整数替换 %f 浮点数替换 %x 十六进制整数替换 %% 表示一个 % ok，基础语法的介绍就到这里，我们下篇再见。]]></content>
      <tags>
        <tag>Python 基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 入门之环境搭建]]></title>
    <url>%2F2017%2F08%2F04%2F2017-08-04%20Python3%20%E5%85%A5%E9%97%A8%E4%B9%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[前言 ：人生苦短，我用 Python 概述Python 是目前最为火热的脚本语言之一，它 “优雅、明确、简单”，被应用于后台服务，网站 Web，数据分析，机器学习等方方面面。作为一个 Android 开发人员，也是很有必要掌握一门第二语言，这里就记录下我的 Python 学习之路，主要学习廖雪峰的 Python 教程。 Python 安装Python 是跨平台的，可以运行于 Windows、Mac 和各种 Linux／Unix 系统上。目前 Python 有两个版本，一个是 2.x 版，一个是 3.x 版，可气的是 3.x 版本居然不向前兼容 2.x 版本；由于目前 3.x 版本越来越普及， 我们就以 Python 3.x 版本开始学习吧。 Mac 安装 Python我的 Mac 版本号是 10.12.5，系统自带 Python 2.7，因此我们需要安装 Python 3.x 版本。 Python 官网下载最新版本，双击安装即可 如果安装了 Homebrew，直接通过命令 brew install python3 安装即可 运行 Python在命令行中输入 python3 即可看到如下信息，说明我们安装成功。前面不是说系统有自带 Python 2.7 版本吗，在命令行中输入 python 即可使用 2.7 版本。 看到如上图所示的系统提示符 &gt;&gt;&gt;，说明已经进入 Python 运行环境，在这里即可开始进行程序的编辑及运行。退出 Python 运行环境也很简单，直接命令行输入 exit() 即可。 第一个 Python 程序Python 交互式环境在交互式环境提示符 &gt;&gt;&gt; 下，使用 print() 函数输出指定字符串，字符串使用单引号或双引号均可，但是不能混用单双引号。交互式模式相当于启动了 Python 解释器，等待一行行的代码输入并一行行执行。 &gt;&gt;&gt; print(&apos;Hello Python!&apos;) Hello Python! 命令行模式新建文件 hello.py ，将上述内容写入后保存，打开命令行，输入 python3 hello.py 即可得到输出结果。这种模式相当于启动解释器，一次性将源代码读取执行了，用户不能向交互式模式那样输入源码。 ➜ Desktop python3 hello.py Hello Python! 文本编辑器在交互模式下，可以一下子就得到结果，但是没法保存程序，每次运行时都需要重新输入一遍。因此我们一般都是把程序保存成 .py 格式的文件，后续就可以反复使用运行了。 编辑器使用 Sublime Text 或 Nodepad++ 等市面上常见的编辑器均可，但是千万不要使用 Word 和 Windows 系统自带的记事本编辑。 直接运行 Python 文件如果你想在 Mac 下直接运行 Python 文件，那么只需要在 .py 文件的第一行加上如下特殊解释 123#!/user/bin/env python3print(&apos;Hello Python!&apos;) 然后，给文件添加执行权限 1chmod a+x hello.py 即可直接在命令行运行该文件了 ./hello.py ok，到现在为止，我们已经安装了 Python 开发环境、开发了第一个 Python 程序，怎么样，是不是感觉比较简单呢。我们下一篇将开始进行 Python 的语法学习！]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 控件的使用]]></title>
    <url>%2F2017%2F08%2F02%2F2017-08-02%20RecyclerView-%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 最近在做一个滑动列表的需求，现将 RecyclerView 的使用知识记录总结下 概述RecyclerView 是 android.support.v7 包下的一个组件，根据官方文档说明，它是一个可以在有限屏幕区域提供大量数据集的灵活视图组件。 那么它和我们熟悉的 ListView 和 GridView 有什么区别呢，或者说对比已有的两个组件，RecyclerView 有什么优势呢？整体来说，RecyclerView 提供了更为灵活的体验，高度解耦，开发者可以使用不同的 LayoutManager，ItemDecoration，ItemAnimator 来实现各种自定义效果。 LayoutManager 通过布局管理器，可以轻松实现类似 ListView，GridView 和 流式布局等效果 ItemDecoration 通过它可以控制 Item 间的间隔，实现自定义间隔样式 ItemAnimator 使用它来控制 Item 的增删等动画效果 点击事件 RecyclerView 的点击事件需要自己来实现（提供了 OnItemTouchListener 接口） 使用导入库包在 gradle 文件中引入 v7 包 compile &#39;com.android.support:recyclerview-v7:21.0.3&#39; 布局中使用在 xml 布局文件中使用 &lt;android.support.v7.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt; Activity 中设置在 Activity 中获取 RecyclerView 组件，进行以下设置： 设置数据适配器（必须） 设置布局管理器（必须） 设置 Item 增加、移除动画（非必须） 添加分割线（非必须） Adapter继承实现 RecyclerView.Adapter&lt;VH extends ViewHolder&gt; 类，作为 RecyclerView 的数据适配器，主要实现以下几个方法 onCreateViewHolder（创建 ViewHoldre，初始化填充 ItemView 布局） onBindViewHolder（绑定 ViewHolder，进行数据的展示处理） getItemViewType（获取 ItemView 类型，主要运用于多布局） getItemCount（获取 Item 个数） 注意在 onCreateViewHolder 中，填充 View 时建议使用如下格式： 1View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_1, parent, false); LayoutManagerRecyclerView.LayoutManager 是一个抽象类，系统默认提供了三个实现类： LinearLayoutManager 线性布局管理器，支持横向及纵向布局 GridLayoutManager 网格式布局管理器 StaggeredGridLayoutManager 瀑布流式布局管理器 将不同布局管理器设置到 RecyclerView 中，即可实现不同的布局；当然也可以继承 RecyclerView.LayoutManager 从而实现自定义布局 ItemDecoration通过 RecyclerView.addItemDecoration() 方法可以添加分割线，该类为一个抽象类，开发者需要自己来进行实现 public static abstract class ItemDecoration { public void onDraw(Canvas c, RecyclerView parent, State state) { onDraw(c, parent); } @Deprecated public void onDraw(Canvas c, RecyclerView parent) { } public void onDrawOver(Canvas c, RecyclerView parent, State state) { onDrawOver(c, parent); } @Deprecated public void onDrawOver(Canvas c, RecyclerView parent) { } @Deprecated public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) { outRect.set(0, 0, 0, 0); } public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) { getItemOffsets(outRect, ((LayoutParams) view.getLayoutParams()).getViewPosition(),parent); } } 当我们使用 RecyclerView.addItemDecoration 方法时，RecyclerView 会进行绘制，主要是通过 onDraw() 和 onDrawOver() 方法 onDraw() : 绘制分割线 onDrawOver() : 在 onDraw() 之后绘制，一般覆写其中一个即可 getItemOffsets() : 通过 outRect.set() 为每个 item 设置偏移量，即用来设置分割线的宽、高 Item AnimatorRecyclerView 能够通过 mRecyclerView.setItemAnimator(ItemAnimator animator) 设置添加、删除、移动、改变的动画效果。RecyclerView 提供了默认的 ItemAnimator 实现类：DefaultItemAnimator 多布局实现RecyclerView 可以通过 getItemViewType 获取不同的布局类型，进行对应布局的填充，有点类似 ListView ；利用这个接口可以轻松实现头布局和尾布局的添加 结语综合来看，RecyclerView 提供了一种低耦合，插拔式的滑动布局体验，通过 LayoutManager 可以只需一行代码实现布局格式的切换，轻松实现 ListView、GridView 等布局效果，更是可以支持自定义分割线处理。 参考 Android RecyclerView 使用完全解析 DividerItemDecoration RecyclerView 优秀文集]]></content>
      <tags>
        <tag>RecyclerView</tag>
        <tag>SupportV7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 下 Hexo 和 Github 搭建博客]]></title>
    <url>%2F2017%2F06%2F30%2F2017-06-30%20Mac-%E4%B8%8B-Hexo-%E5%92%8C-Github-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[写在前面之前在 Windows 下操作过一次博客搭建过程，不过后面没有写什么内容，也就慢慢废弃了。转岗到新部门后申请到了 Mac 电脑，在使用了一段时间之后，不得不感慨 Mac 电脑对于开发人员的便捷舒适。这里尽量将自己平时的工作总结进行记录备忘，那么就从搭建博客开始吧。 注册 GitHub 账号在 Github 上进行注册，这个比较简单，按照正常操作即可。 创建仓库 (repo)，这个仓库是和我们的博客关联起来的，后续博客文章资源都是存放在这个仓库当中。使用 Hexo 时，repo 的名字应该按照 your_github_username.github.io 来命名。一个账号一般只能对应一个博客。 安装 Git、Node.js 和 Hexo Mac 电脑本身自带 Git ，无需安装 在 Nodejs 官网下载安装；用来下载 Hexo 等工具及插件 在命令行使用 npm install -g hexo-cli 来下载安装 Hexo 注意: 公司开发网需要设置代理 npm config set proxy=http://dev-proxy.oa.com:8080 如果发现没有权限，则使用如下命令 sudo npm install -g hexo-cli 搭建博客博客初始化建立一个博客文件夹，比如 “GitRoom”，进入到文件夹后进行初始化操作 12$ cd GitRoom$ hexo init 安装依赖包 1$ npm install 这样设置后，我们就可以在博客文件夹中看到多了很多文件和目录 博客配置博客站点的配置信息在 _config.yml 文件中，我们主要修改如下几点即可（注意每一项的「 : 」后需要保留一个空格） 网站基本信息 123456title: bashellwang 的小书屋subtitle:description: 路漫漫其修远兮author: bashellwanglanguage: zh-Hanstimezone: Asia/Shanghai 绑定 Github 1234deploy: type: git repo: https://github.com/bashellwang/bashellwang.github.io.git branch: master 博客本地部署测试一般我们在发布到正式环境前会先本地部署看看效果，使用如下命令： 1$ hexo server 此时，正常情况下应该会显示如下；在浏览器中输入 http://localhost:4000/ 即可看到搭建好的博客和文章了。 博客发布到正式环境12$ npm install hexo-deployer-git --save$ hexo deploy 这时我们就可以在 GitHub 的仓库中看见我们提交的网站相关资源了；此时在浏览器中输入 your_github_name.github.io 就可以打开我们博客的主页了。 新建文章1$ hexo new &quot;article_title&quot; 即可在本地文件夹 /source/_post 下看到我们新建的 markdown 文件；使用 markdown 编辑器编写文章内容后保存（ mac 推荐使用 MacDown 软件）；生成静态网页文件并发布到网上 12$ hexo generate$ hexo deploy 更多 Hexo 操作请参考 Hexo 操作指南 删除文章在本地文件夹 /source/_post 目录下删除对应的 .md 文件，然后重新生成静态网页文件并发布 12$ hexo generate$ hexo deploy 每次当博客发生问题或错误时，建议先进行 clean 操作并重新生成静态网页 12$ hexo clean$ hexo g Hexo 常用命令1234567891011121314hexo help #查看帮助hexo init #初始化一个目录hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，&apos;Ctrl+C&apos;关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，**强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹**简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 博客主题修改Hexo 支持多种主题，并且可以轻易修改主题风格。下面以我的站点 https://bashellwang.github.io/ 来进行简单说明Hexo 主要有两份配置文件（文件名均为 _config.yml）：一份在站点根目录下，一份在主题 theme 目录下，我们可以分别称为站点配置文件和主题配置文件。 在 theme 目录下下载主题 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 站点配置文件中启用主题 1theme: next 主题配置文件中选用主题特性，使用 Pisces 特性 123#scheme: Muse#scheme: Mistscheme: Pisces 这样即完成了基本的网站主题设置，更多详情请参考 NexT 使用文档 最终成品https://bashellwang.github.io/]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F06%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>